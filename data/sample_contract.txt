# Sample Smart Contract Bytecode
# This file contains example smart contracts in our custom bytecode format

# Contract 1: Simple Addition
# Pushes two numbers onto the stack and adds them
# Expected result: 30 (10 + 20)

# PUSH 10 (0x01 followed by 8 bytes)
01 0A 00 00 00 00 00 00 00

# PUSH 20 (0x01 followed by 8 bytes)
01 14 00 00 00 00 00 00 00

# ADD (0x03)
03

# HALT (0x18)
18

---

# Contract 2: Factorial Calculation
# Calculates factorial of 5 using loops

# PUSH 5 (input number)
01 05 00 00 00 00 00 00 00

# PUSH 1 (accumulator)
01 01 00 00 00 00 00 00 00

# PUSH 1 (counter)
01 01 00 00 00 00 00 00 00

# Loop start (address 28)
# DUP counter
# PUSH 5
01 05 00 00 00 00 00 00 00

# GT (greater than)
0E

# JMPIF to end (address 60)
11 3C 00 00 00

# Multiply accumulator by counter
# (stack manipulation and multiplication)
05

# Increment counter
01 01 00 00 00 00 00 00 00
03

# JMP to loop start
10 1C 00 00 00

# HALT
18

---

# Contract 3: Hash Verification
# Verifies a hash against expected value

# PUSH data address (0)
01 00 00 00 00 00 00 00 00

# PUSH data length (32)
01 20 00 00 00 00 00 00 00

# HASH
16

# PUSH expected hash (example)
01 AB CD EF 12 34 56 78 90

# EQ (compare)
0C

# VERIFY
17

# HALT
18

---

# Contract 4: Storage Operations
# Demonstrates reading and writing to storage

# PUSH key (42)
01 2A 00 00 00 00 00 00 00

# PUSH value (100)
01 64 00 00 00 00 00 00 00

# STORE
15

# PUSH same key (42)
01 2A 00 00 00 00 00 00 00

# LOAD
14

# PUSH expected value (100)
01 64 00 00 00 00 00 00 00

# EQ (verify loaded value)
0C

# HALT
18

---

# Contract 5: Conditional Logic
# Demonstrates conditional execution

# PUSH 10
01 0A 00 00 00 00 00 00 00

# PUSH 5
01 05 00 00 00 00 00 00 00

# GT (10 > 5)
0E

# JMPIF to true branch (address 40)
11 28 00 00 00

# False branch: PUSH 0
01 00 00 00 00 00 00 00 00
# JMP to end
10 30 00 00 00

# True branch: PUSH 1
01 01 00 00 00 00 00 00 00

# HALT
18

---

# Instructions Reference:
# 00 - NOP      (No operation)
# 01 - PUSH     (Push 8-byte value)
# 02 - POP      (Pop from stack)
# 03 - ADD      (Add top two stack values)
# 04 - SUB      (Subtract)
# 05 - MUL      (Multiply)
# 06 - DIV      (Divide)
# 07 - MOD      (Modulo)
# 08 - AND      (Bitwise AND)
# 09 - OR       (Bitwise OR)
# 0A - XOR      (Bitwise XOR)
# 0B - NOT      (Bitwise NOT)
# 0C - EQ       (Equal comparison)
# 0D - LT       (Less than)
# 0E - GT       (Greater than)
# 0F - JMP      (Unconditional jump)
# 10 - JMPIF    (Conditional jump)
# 11 - CALL     (Function call)
# 12 - RET      (Return)
# 13 - LOAD     (Load from storage)
# 14 - STORE    (Store to storage)
# 15 - HASH     (Compute hash)
# 16 - VERIFY   (Verify signature)
# 17 - HALT     (Stop execution)

# Gas Costs:
# NOP: 1, PUSH: 3, POP: 2
# Arithmetic (ADD/SUB/MUL/DIV/MOD): 3-5
# Bitwise (AND/OR/XOR/NOT): 3
# Comparison (EQ/LT/GT): 3
# Control flow (JMP/JMPIF): 8-10
# Function calls (CALL/RET): 40/5
# Storage (LOAD/STORE): 200/5000
# Crypto (HASH/VERIFY): 30/3000